# GCRoots

> 内存中已经不被使用到的空间就是垃圾

## 如何判读是否能被回收

+ 引用计数法
+ 枚举根节点做可达性分析（根路径搜索）

## GCRoot

​	所谓GCRoot就是一组必须活跃的饮用 基本思路就是通过一系列**名为"GCRoots"的对象**作为起始点从这个被称为GCRoot的根节点开始向下搜索 如果一个对象到GCRoot没有任何引用链相连时 说明此对象不可用 也即给定一个集合的引用作为根出发 通过引用关系遍历图 能被遍历到的（可达到的）对象被判断为存活 没有遍历到的就自然的被判定为死亡。

## Java中可以最为GCRoot的对象

1. 虚拟机栈（栈桢中的局部变量区 也叫局部变量表）中引用的对象
   + 比如各个线程被调用的方法中使用到的参数 局部变量等

1. 方法区中的类静态属性引用的对象
   + Java类中的引用类型静态变量
2. 方法区中常量引用的对象
   + 字符串常量池（String Table）中的引用
3. 本地方法栈中JNI（Native方法）引用的对象
4. 所有被同步锁synchronized持有的对象
5. Java虚拟机内部的引用
   + 基本数据类型对应的class对象
   + 一些常驻的异常对象（NullPointerException，OOME）

Tips：由于Root采用栈方式存放变量和引用 所以一根引用保存了堆内存中的对象 但是自己又不存放在堆内存中 那他就是一个Root

## 可达性分析算法

搜索被根对象集合所连接的目标对象是否可达

搜索所走过的路径被称为**引用链**

注意：如果要是用可达性分析算法来判断内存是否回收 那么分析工作必须在一个能保障一致性的快照中进行 着点不满足的话 分析的结果就无法保证准确 这点也是导致GC必须 Stop The World的一个重要原因 即使是号称几乎不会停顿的CMS 枚举根节点时也是必须要停顿的















