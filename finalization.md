# 对象的finalization机制

Java语言提供了对象终止（finalization）机制来允许开发人员提供**对象被销毁之前的自定义处理逻辑**

当垃圾回收器发现没有一个引用指向一个对象 即：垃圾回收此对象前 总会先调用这个对象的finalize()方法

finalize()允许子类重写**用于在对象回收时进行资源释放**

***

永远不要主动调用某个对象的finalize()方法 应该交给垃圾回收机制调用 理由包括下面三点：

+ 在finalize()时可能导致对象复活
+ finalize()方法的执行时间是没有保障的 它完全由GC线程决定 极端情况下 若不发生GC 则fanalize()方法永远不执行
+ 一个糟糕的finalize()方法会严重影响GC性能

***

由于finalize()方法的存在 **虚拟机中的对象一般处于三种可能的状态**

如果从所有的根节点都无法访问到某个对象 说明对象已经不在使用了 一般来说 此对象需要被回收 但事实上 也不是非死不可的 这时候他们暂时处于缓刑阶段 **一个无法触及的对象有可能在某一个条件下复活自己** 如果这样 那么对他的回收就是不合理的 为此 定义虚拟机中的对象可能的三种状态为：

+ **可触及的** 从根节点开始 可以达到这个对象
+ **可复活的** 对象的所有引用都被释放 但是对象可能在finalize()方法中复活
+ **不可触及的** 对象的finalize()方法被调用 并且没有复活 那么就会进入不可触及状态 不可触及的对象不可能被复活 因为**finalize()方法只能被调用一次**

以上三种状态中 是由于finalize()方法的存在 进行的区分 只有在对象不可触及时候才可以被回收

***

判断一个对象objA是否可回收 至少要经历两次标记过程

1. 如果对象objA到GCRoots没有引用链 则进行第一次标记
2. 进行筛选 判断此对象是否有必要执行finalize()方法
   1. 如果对象objA没有重写finalize()方法 或者finalize()方法已经被虚拟机调用过 则虚拟机认为没有必要执行 objA被判定为不可触及的
   2. 如果对象重写了finalize()方法 且未被执行过 那么objA会被插入到F-QUEUE队列中 由一个虚拟机自动创建的 低优先级的Finalizer线程触发其finalize()方法
   3. **finalize()方法是对象逃脱死亡的最后机会** 稍后GC会对F-QUEUE中的对象进行第二次标记 如果objA在finalize()方法中与引用链上的任何一个对象建立了联系 那么在第二次标记时 objA会被移出“即将回收”集合之后 对象会再次出现没有引用存在的情况 在这个情况下 finalize()方法不会被再次调用 对象会直接变成不可触及的状态 也就是说 一个对象的finalize()方法只会被调用一次



